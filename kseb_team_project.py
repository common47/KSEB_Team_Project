# -*- coding: utf-8 -*-
"""KSEB Team Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11hkRAy2KOk-EHrKhtEtVzWBJSRLySiII

# 라이브러리 설치 및 관리
"""

!pip install ultralytics

# import locale
# locale.getpreferredencoding = lambda: "UTF-8"

# from google.colab import drive
# drive.mount("/content/gdrive")

"""# 1. 커스텀 모델"""

# %cd /content/gdrive/MyDrive/Colab Notebooks/code2024/Session13 - 객체인식모델 연동실습_yolo

"""### 1-1. 커스텀모델용 이미지 준비"""

!pip install roboflow

# from roboflow import Roboflow
# rf = Roboflow(api_key="본인 키")
# project = rf.workspace("hkyolo").project("drinkproject-9ak04")
# version = project.version(3)
# dataset = version.download("yolov9")

# !pip install roboflow

# from roboflow import Roboflow
# rf = Roboflow(api_key="Zc4NbgwKcNj2sTMq4ySz")
# project = rf.workspace("hkyolo").project("drinkproject-9ak04")
# version = project.version(3)
# dataset = version.download("yolov11")

# !pip install roboflow

# from roboflow import Roboflow
# rf = Roboflow(api_key="c4bFkTzz5a6XFkHjRRK9")
# project = rf.workspace("facode").project("fire-and-smoke-v1")
# version = project.version(1)
# dataset = version.download("yolov11")

!pip install roboflow

from roboflow import Roboflow
rf = Roboflow(api_key="c4bFkTzz5a6XFkHjRRK9")
project = rf.workspace("fire-smoke-od").project("small-fire-smoke-od-dataset")
version = project.version(6)
dataset = version.download("yolov11")

# !pip install roboflow

# from roboflow import Roboflow
# rf = Roboflow(api_key="c4bFkTzz5a6XFkHjRRK9")
# project = rf.workspace("ghulam-ishaq-khan-institute-3qit1").project("forest-fire-detection-fis51")
# version = project.version(9)
# dataset = version.download("yolov11")

"""### 1-2. 커스텀모델용 모델 준비"""

from ultralytics import YOLO

# Load a pretrained YOLOv10n model
# model = YOLO("yolov12n.pt")
model = YOLO("yolo11n.pt")
imgPath = "/content/Small-Fire-Smoke-OD-Dataset-6/data.yaml"
model.train(data=imgPath,
             epochs=50,
             patience=10,
             batch=32)

# 이미지파일 경로 표시
source = "/content/화재.mp4"

# 예측모델 구동
results = model(source=source, save=True)

import cv2

# 영상 파일 경로
video_path = '/content/화재.mp4'
# 최종적으로 저장할 동영상 파일 경로
output_video_path = '/content/yolo_test_video_reconstructed2.mp4'
fps = 30  # 저장할 동영상의 프레임 속도 (FPS)

# 비디오 캡처 객체 생성
capture = cv2.VideoCapture(video_path)

# 프레임 크기 가져오기
frame_width = int(capture.get(cv2.CAP_PROP_FRAME_WIDTH))
frame_height = int(capture.get(cv2.CAP_PROP_FRAME_HEIGHT))

# 비디오 라이터 객체 생성
fcc = cv2.VideoWriter_fourcc(*'mp4v')
video_writer = cv2.VideoWriter(output_video_path, fcc, fps, (frame_width, frame_height))

# 프레임을 하나씩 읽어와서 바로 새로운 MP4 파일에 저장
while capture.isOpened():
    ret, frame = capture.read()
    if ret:
        detection = model(frame)[0]
        boxInfos = detection.boxes.data.tolist()
        for i in range(0, len(boxInfos)):
            data = boxInfos[i]
            # data : [xmin, ymin, xmax, ymax, confidence_score, class_id]
            # 바운딩박스 사각형을 그리기 위해서 좌표 값 불러오기
            xmin, ymin, xmax, ymax = int(data[0]), int(data[1]), int(data[2]), int(data[3])
            # 바운딩박스 사각형 그리기
            cv2.rectangle(frame, (xmin, ymin), (xmax, ymax), (0,255,0), 2)

            #클래스명 불러오기
            label = int(data[5])
            classNames = model.names
            classLabel = classNames[label]
            confidence = str(round(data[4],2))
            textValue = classLabel+'_' + confidence + '%'
            #클래스명 및 confidence 붙이기
            cv2.putText(frame, textValue, (xmin, ymin), cv2.FONT_ITALIC, 1, (255,255,255), 2)
            # 프레임 저장
        # 프레임을 비디오에 저장
        video_writer.write(frame)
    else:
        break

# 비디오 캡처 및 라이터 객체 해제
capture.release()
video_writer.release()

print(f"Video reconstructed and saved as {output_video_path}")

pip install pyttsx3

!pip install gTTS

import cv2
import pyttsx3

# TTS 엔진 초기화
engine = pyttsx3.init()
is_fire_announced = False  # TTS 중복 방지용 플래그

# 영상 파일 경로
video_path = '/content/화재.mp4'
output_video_path = '/content/yolo_test_video.mp4'
fps = 30

# 비디오 캡처 객체 생성
capture = cv2.VideoCapture(video_path)
frame_width = int(capture.get(cv2.CAP_PROP_FRAME_WIDTH))
frame_height = int(capture.get(cv2.CAP_PROP_FRAME_HEIGHT))

# 비디오 라이터 객체 생성
fcc = cv2.VideoWriter_fourcc(*'mp4v')
video_writer = cv2.VideoWriter(output_video_path, fcc, fps, (frame_width, frame_height))

# 프레임 처리 루프
while capture.isOpened():
    ret, frame = capture.read()
    if not ret:
        break

    detection = model(frame)[0]
    boxInfos = detection.boxes.data.tolist()
    for data in boxInfos:
        xmin, ymin, xmax, ymax = int(data[0]), int(data[1]), int(data[2]), int(data[3])
        confidence = data[4]
        label = int(data[5])

        # confidence가 0.5 이상일 때만 처리
        if confidence >= 0.5:
            classNames = model.names
            classLabel = classNames[label]
            textValue = f"{classLabel}_{round(confidence * 100, 2)}%"

            # 바운딩박스 그리기
            cv2.rectangle(frame, (xmin, ymin), (xmax, ymax), (0, 255, 0), 2)
            cv2.putText(frame, textValue, (xmin, ymin), cv2.FONT_ITALIC, 1, (255, 255, 255), 2)

    # 프레임을 비디오에 저장
    video_writer.write(frame)

# 자원 해제
capture.release()
video_writer.release()

print(f"Video reconstructed and saved as {output_video_path}")

model.save("fire.pt")

